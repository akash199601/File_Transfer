<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>File Transfer (P2P) - Python</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto;max-width:900px;margin:24px auto;padding:12px}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    input, button {padding:8px;border:1px solid #ccc;border-radius:6px}
    #qr {width:160px;height:160px}
    #messages {margin-top:12px}
    #files {margin-top:12px}
    a.download {display:block;margin-top:6px}
  </style>
</head>
<body>
  <h2>Python P2P FileShare</h2>

  <div class="row">
    <button id="createBtn">Create Room (Mobile)</button>
    <input id="roomInput" placeholder="Enter room ID or paste URL" style="flex:1"/>
    <button id="joinBtn">Join Room (Laptop)</button>
  </div>

  <div id="createdArea" style="display:none; margin-top:12px;">
    <p>Share this Room link or scan QR from laptop:</p>
    <input id="roomUrl" readonly style="width:100%"/>
    <div id="qr"></div>
  </div>

  <div id="transfer" style="display:none;">
    <p><strong>Connected.</strong> Choose file(s) to send:</p>
    <input type="file" id="fileInput" multiple />
    <div id="progress"></div>
    <div id="messages"></div>
    <div id="files"></div>
  </div>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<script>
const socket = io();
let pc, dc;
let roomId = '';
const STUN_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

document.getElementById('createBtn').onclick = () => {
  socket.emit('create-room');
};

socket.on('room-created', (data) => {
  roomId = data.room;
  const url = location.origin + '/?room=' + roomId;
  document.getElementById('roomUrl').value = url;
  document.getElementById('createdArea').style.display = 'block';
  // show QR
  document.getElementById('qr').innerHTML = '';
  new QRCode(document.getElementById('qr'), { text: url, width:160, height:160 });
  initPeer(true);
});

document.getElementById('joinBtn').onclick = () => {
  const v = document.getElementById('roomInput').value.trim();
  if (!v) { alert('Enter room id or URL'); return; }
  // if full URL provided, extract `room` param
  try {
    const u = new URL(v);
    const r = u.searchParams.get('room');
    if (r) roomId = r;
    else roomId = v;
  } catch (e) {
    roomId = v;
  }
  socket.emit('join-room', { room: roomId });
  initPeer(false);
};

socket.on('peer-joined', () => {
  // When a peer joins the room (for the caller), create offer
  if (pc && dc && pc.signalingState === 'stable') {
    createAndSendOffer();
  }
});

socket.on('signal', async (data) => {
  if (!pc) return;
  if (data.type === 'offer') {
    await pc.setRemoteDescription(data.sdp);
    const a = await pc.createAnswer();
    await pc.setLocalDescription(a);
    socket.emit('signal', { room: roomId, type: 'answer', sdp: pc.localDescription });
  } else if (data.type === 'answer') {
    await pc.setRemoteDescription(data.sdp);
  } else if (data.type === 'candidate') {
    try { await pc.addIceCandidate(data.candidate); } catch(e){}
  }
});

socket.on('peer-left', () => {
  appendMsg('Peer left');
  // reset UI if needed
});

function initPeer(isCaller){
  pc = new RTCPeerConnection(STUN_CONFIG);
  pc.onicecandidate = e => {
    if (e.candidate) {
      socket.emit('signal', { room: roomId, type: 'candidate', candidate: e.candidate });
    }
  };
  pc.ondatachannel = e => {
    dc = e.channel;
    setupDataChannel();
  };
  if (isCaller) {
    dc = pc.createDataChannel('file');
    setupDataChannel();
  }
  // show connected UI once DC opens
}

function createAndSendOffer(){
  pc.createOffer().then(o=>{
    pc.setLocalDescription(o);
    socket.emit('signal', { room: roomId, type: 'offer', sdp: pc.localDescription });
  });
}

function setupDataChannel(){
  dc.binaryType = 'arraybuffer';
  dc.onopen = () => {
    document.getElementById('transfer').style.display = 'block';
    appendMsg('DataChannel open â€” you can send files now');
  };
  dc.onmessage = handleIncoming;
}

// Incoming file handling
let incoming = null;
function handleIncoming(e){
  if (typeof e.data === 'string') {
    const meta = JSON.parse(e.data);
    incoming = { name: meta.name, size: meta.size, received: 0, buffers: [] };
    updateProgress(0, incoming.size);
    appendMsg('Receiving: ' + incoming.name);
    return;
  }
  incoming.buffers.push(e.data);
  incoming.received += e.data.byteLength;
  updateProgress(incoming.received, incoming.size);
  if (incoming.received === incoming.size) {
    const blob = new Blob(incoming.buffers);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = incoming.name;
    a.className = 'download';
    a.textContent = 'Download ' + incoming.name;
    document.getElementById('files').appendChild(a);
    appendMsg('File received: ' + incoming.name);
    incoming = null;
  }
}

function appendMsg(t){
  const d = document.createElement('div'); d.textContent = t;
  document.getElementById('messages').appendChild(d);
}

function updateProgress(done, total){
  document.getElementById('progress').textContent = `Progress: ${Math.round(done/total*100)}% (${done}/${total})`;
}

// file sending
document.getElementById('fileInput').addEventListener('change', async (ev) => {
  const files = ev.target.files;
  for (const f of files){
    await sendFile(f);
  }
});

async function sendFile(file){
  if (!dc || dc.readyState !== 'open') return alert('DataChannel not open yet');
  appendMsg('Sending: ' + file.name);
  dc.send(JSON.stringify({ name: file.name, size: file.size }));
  const chunkSize = 64 * 1024; // 64KB
  const buffer = await file.arrayBuffer();
  for (let i=0; i < buffer.byteLength; i += chunkSize) {
    dc.send(buffer.slice(i, i + chunkSize));
    // simple backpressure control
    if (dc.bufferedAmount > 1e6) {
      await new Promise(r => setTimeout(r, 50));
    }
  }
  appendMsg('Sent: ' + file.name);
}

// Auto-join if ?room= present in URL (makes laptop side easier)
const preRoom = new URLSearchParams(location.search).get('room');
if (preRoom) {
  document.getElementById('roomInput').value = preRoom;
  // optionally auto-join (comment if you want manual press)
  // document.getElementById('joinBtn').click();
}
</script>
</body>
</html>
